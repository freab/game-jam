/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef } from "react";
import { useGLTF, PerspectiveCamera } from "@react-three/drei";
import { useThree } from "@react-three/fiber";
import useCameraStore from "../store/cameraStore";
import * as THREE from "three";
import gsap from "gsap";

const getShortestRotation = (current, target) => {
  let diff = target - current;
  diff = ((diff + Math.PI) % (2 * Math.PI)) - Math.PI;

  if (Math.abs(diff) > Math.PI - 1e-6) {
    if (diff > 0) {
      diff = -(2 * Math.PI - diff);
    } else {
      diff = 2 * Math.PI + diff;
    }
  }

  return diff;
};

const eulerToQuaternion = (x, y, z, order = "XYZ") => {
  const euler = new THREE.Euler(x, y, z, order);
  return new THREE.Quaternion().setFromEuler(euler);
};

const calculateAnimationDuration = (
  currentPos,
  targetPos,
  currentRot,
  targetRot
) => {
  const distance = Math.sqrt(
    Math.pow(targetPos.x - currentPos.x, 2) +
      Math.pow(targetPos.y - currentPos.y, 2) +
      Math.pow(targetPos.z - currentPos.z, 2)
  );

  const rotDiff =
    Math.abs(targetRot.y - currentRot.y) +
    Math.abs(targetRot.x - currentRot.x) +
    Math.abs(targetRot.z - currentRot.z);

  const baseDuration = 1.2;
  const distanceFactor = Math.min(distance / 10, 1.5);
  const rotationFactor = Math.min(rotDiff / Math.PI, 1.3);

  return baseDuration + distanceFactor * 0.8 + rotationFactor * 0.6;
};

const animateCameraWithQuaternion = (
  camera,
  targetPosition,
  targetRotation,
  baseDuration,
  onComplete
) => {
  const startPosition = camera.position.clone();
  const startQuaternion = camera.quaternion.clone();
  const targetQuaternion = eulerToQuaternion(
    targetRotation.x,
    targetRotation.y,
    targetRotation.z
  );

  const duration = calculateAnimationDuration(
    startPosition,
    targetPosition,
    camera.rotation,
    targetRotation
  );

  const distance = startPosition.distanceTo(
    new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z)
  );
  const shouldUseArcPath = distance > 5;

  let intermediatePosition = null;
  if (shouldUseArcPath) {
    const midPoint = new THREE.Vector3().lerpVectors(
      startPosition,
      new THREE.Vector3(targetPosition.x, targetPosition.y, targetPosition.z),
      0.5
    );
    midPoint.y += Math.min(distance * 0.1, 2);
    intermediatePosition = midPoint;
  }

  const animationData = {
    progress: 0
  };

  const tl = gsap.timeline({
    onComplete: () => {
      camera.position.set(targetPosition.x, targetPosition.y, targetPosition.z);
      camera.quaternion.copy(targetQuaternion);
      if (onComplete) onComplete();
    }
  });

  tl.to(animationData, {
    progress: 1,
    duration: duration,
    ease: "power3.inOut",
    onUpdate: () => {
      const progress = animationData.progress;

      if (shouldUseArcPath) {
        const t = progress;
        const invT = 1 - t;

        const currentPos = new THREE.Vector3(
          invT * invT * startPosition.x +
            2 * invT * t * intermediatePosition.x +
            t * t * targetPosition.x,
          invT * invT * startPosition.y +
            2 * invT * t * intermediatePosition.y +
            t * t * targetPosition.y,
          invT * invT * startPosition.z +
            2 * invT * t * intermediatePosition.z +
            t * t * targetPosition.z
        );

        camera.position.copy(currentPos);
      } else {
        camera.position.lerpVectors(
          startPosition,
          new THREE.Vector3(
            targetPosition.x,
            targetPosition.y,
            targetPosition.z
          ),
          progress
        );
      }

      camera.quaternion.slerpQuaternions(
        startQuaternion,
        targetQuaternion,
        progress
      );
    }
  });
};

export function AnimationAndObjects(props) {
  const { nodes, materials } = useGLTF("/Animation and cameras.glb");
  const { camera } = useThree();
  const {
    setCameraPosition,
    setCameraRotation,
    setIsWalking,
    setActiveCamera,
    isWalking,
    setTargetCameraPosition,
    setTargetCameraRotation
  } = useCameraStore();

  const handleMeshClick = (cameraName) => {
    const targetCamera = nodes[cameraName];
    if (targetCamera) {
      const position = targetCamera.position;
      const rotation = targetCamera.rotation;

      // Update camera store
      setCameraPosition([position.x, position.y, position.z]);
      setCameraRotation([rotation.x, rotation.y, rotation.z]);
      setActiveCamera(cameraName);
      setIsWalking(false);

      // Update camera in three.js
      animateCameraWithQuaternion(camera, position, rotation, 1.2, () => {
        camera.position.set(position.x, position.y, position.z);
        camera.rotation.set(rotation.x, rotation.y, rotation.z);
      });
    }
  };

  return (
    <group {...props} dispose={null}>
      <mesh
        name="vinyl_obj"
        castShadow
        receiveShadow
        geometry={nodes.vinyl_obj.geometry}
        material={nodes.vinyl_obj.material}
        position={[-12.357, 3.042, -11.476]}
        scale={[1.434, 1, 1]}
        onClick={() => handleMeshClick("vinyl_camera")}
      />
      <mesh
        name="telephone_obj"
        castShadow
        receiveShadow
        geometry={nodes.telephone_obj.geometry}
        material={nodes.telephone_obj.material}
        position={[-8.581, 3.042, -11.476]}
        scale={[1.434, 1, 1]}
        onClick={() => handleMeshClick("telephone_camera")}
      />
      <mesh
        name="pc_obj"
        castShadow
        receiveShadow
        geometry={nodes.pc_obj.geometry}
        material={nodes.pc_obj.material}
        position={[2.898, 5.552, -12.541]}
        scale={[1.991, 1.335, 0.357]}
        onClick={() => handleMeshClick("pc_camera")}
      />
      <mesh
        name="paper_obj"
        castShadow
        receiveShadow
        geometry={nodes.paper_obj.geometry}
        material={nodes.paper_obj.material}
        position={[-0.906, 3.656, -11.259]}
        rotation={[0, 0.215, 0]}
        scale={[0.772, 0.149, 0.997]}
        onClick={() => handleMeshClick("paper_camera")}
      />
      <mesh
        name="art_obj"
        castShadow
        receiveShadow
        geometry={nodes.art_obj.geometry}
        material={nodes.art_obj.material}
        position={[10.406, 4.043, -5.754]}
        rotation={[Math.PI / 2, 1.32, -Math.PI / 2]}
        scale={[1.991, 1.335, 0.357]}
        onClick={() => handleMeshClick("art_camera")}
      />
      <mesh
        name="canvas_obj"
        castShadow
        receiveShadow
        geometry={nodes.canvas_obj.geometry}
        material={nodes.canvas_obj.material}
        position={[10.406, 4.043, 4.2]}
        rotation={[Math.PI / 2, 1.32, -Math.PI / 2]}
        scale={[1.991, 1.335, 0.357]}
        onClick={() => handleMeshClick("canvas_camera")}
      />
      <mesh
        name="key_obj"
        castShadow
        receiveShadow
        geometry={nodes.key_obj.geometry}
        material={nodes.key_obj.material}
        position={[10.406, 4.043, 14.198]}
        rotation={[Math.PI / 2, 0.82, -Math.PI / 2]}
        scale={[1.991, 1.335, 0.357]}
        onClick={() => handleMeshClick("key_camera")}
      />
      <mesh
        name="piano_obj"
        castShadow
        receiveShadow
        geometry={nodes.piano_obj.geometry}
        material={nodes.piano_obj.material}
        position={[-14.928, 3.811, 2.992]}
        rotation={[0, -0.128, 0]}
        scale={[0.592, 0.207, 2.783]}
        onClick={() => handleMeshClick("piano_camera")}
      />
      <mesh
        name="clocks_obj"
        castShadow
        receiveShadow
        geometry={nodes.clocks_obj.geometry}
        material={nodes.clocks_obj.material}
        position={[12.513, 12.029, 0.904]}
        rotation={[Math.PI / 2, 1.52, -Math.PI / 2]}
        scale={[8.787, 2.082, 0.468]}
        onClick={() => handleMeshClick("clock_camera")}
      />
      <PerspectiveCamera
        name="pc_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[2.994, 5.442, -3.539]}
        rotation={[0.03, 0, 0]}
      />
      <PerspectiveCamera
        name="vinyl_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[-12.222, 5.442, -3.539]}
        rotation={[-0.284, 0, 0]}
      />
      <PerspectiveCamera
        name="telephone_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[-8.679, 5.442, -3.539]}
        rotation={[-0.284, 0, 0]}
      />
      <PerspectiveCamera
        name="art_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[2.014, 6.162, -5.632]}
        rotation={[-Math.PI / 2, -1.322, -Math.PI / 2]}
      />
      <PerspectiveCamera
        name="canvas_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[2.014, 6.162, 4.089]}
        rotation={[-Math.PI / 2, -1.322, -Math.PI / 2]}
      />
      <PerspectiveCamera
        name="key_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[6.518, 6.162, 18.903]}
        rotation={[-0.525, -0.662, -0.342]}
      />
      <PerspectiveCamera
        name="paper_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[-0.254, 5.442, -7.536]}
        rotation={[-0.48, 0.124, 0.064]}
      />
      <PerspectiveCamera
        name="piano_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[-8.679, 8.472, 2.839]}
        rotation={[-Math.PI / 2, 0.955, Math.PI / 2]}
      />
      <PerspectiveCamera
        name="clock_camera"
        makeDefault={false}
        far={1000}
        near={0.1}
        fov={22.895}
        position={[-13.618, 12.402, 0.94]}
        rotation={[0, -Math.PI / 2, 0]}
      />
    </group>
  );
}

useGLTF.preload("/Animation and cameras.glb");

export default AnimationAndObjects;
